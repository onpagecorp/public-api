import { Injectable, Logger } from '@nestjs/common';
import { PagesListDto } from '../dto/pages-list-dto';
import { Metadata } from '../interfaces/metadata.interface';
import { entity as Entities } from '@onpage-corp/onpage-domain-mysql';
import { PageDto } from '../dto/page-dto';
import { AttachmentShortDto } from '../dto/attachment-short-dto';
import { RecipientDto, RecipientTypeDto } from '../dto/recipient-dto';
import { PageFromDto, PageFromType } from '../dto/page-from-dto';
import { PagePriority, PageSendDto } from '../dto/page-send-dto';
import { Utils } from 'src/utils';

@Injectable()
export class PagesService {
  private static readonly NewApiMessage =
    Entities.sequelize.models.NewApiMessage;
  private readonly logger = new Logger(PagesService.name);

  async findAllPagesByDispatcherId(
    enterpriseId: number,
    dispatcherId: number,
    offset: number,
    limit: number
  ): Promise<PagesListDto> {
    const metadata: Metadata = {
      hasMoreData: false
    };

    const result: PagesListDto = { pages: [], metadata };

    let counter = 0;

    const pushContactToResult = async (message: any) => {
      const shortAttachmentsDto = await this.getMessageShortAttachments(
        message.id
      );
      const recipientsDto = await this.getMessageRecipientsDto(message.id);

      const messageSender = await this.getMessageSender(message);

      result.pages.push(
        PageDto.convertDbMessageToPageDto(
          message,
          shortAttachmentsDto,
          recipientsDto,
          messageSender
        )
      );

      counter++;
    };

    const Message = Entities.sequelize.models.NpsMessage;
    const messages = await Message.findAll({
      where: {},
      include: [
        {
          model: Entities.sequelize.models.Account,
          required: true,
          where: {
            enterpriseId
          }
        },
        {
          model: Entities.sequelize.models.Dispatcher,
          required: false,
          where: {
            enterpriseId
          }
        },
        {
          model: Entities.sequelize.models.NpsMessageRecipient,
          required: true,
          where: {
            enterpriseId
          }
        }
      ],
      offset: offset * limit,
      limit: limit
    });

    for (const message of messages) {
      if (counter >= limit) {
        result.metadata.hasMoreData = true;
        break;
      }
      await pushContactToResult(message.toJSON());
    }

    // return PageDto.convertDbMessageToPageDto(
    //   persistedMessage, [], [], {
    //     id: 0,
    //     type: PageFromType.SYSTEM,
    //     caption: 'System'
    //   });

    return result;
  }

  async sendPage(enterpriseId: number, page: PageSendDto): Promise<PageDto> {
    try {
      const parsedRecipients = await Utils.proceedRecipients(page.recipients);
      if (parsedRecipients.hasNoRecipients) {
        throw new Error('No active recipients.');
      }

      if (
        parsedRecipients.escalationGroupRecipients.length > 0 &&
        (parsedRecipients.regularGroupRecipients.length > 0 ||
          parsedRecipients.individualRecipients.length > 0)
      ) {
        throw new Error('Escalation group has to be the only recipient type.');
      }

      if (parsedRecipients.escalationGroupRecipients.length > 1) {
        throw new Error('Escalation group has to be the only recipient type.');
      }

      const persistedMessage = await this.persistMessageRequest(page);

      return persistedMessage;
    } catch (e) {
      this.logger.error(e.message, e.stack);
      throw new Error('Could not send page.');
    }
  }

  async getPageById(enterpriseId: number, pageId: number): Promise<PageDto> {
    return null;
  }

  private async persistMessageRequest(pageSendDto: PageSendDto) {
    try {
      const type =
        pageSendDto.priority === PagePriority.HIGH ? 'PAGE' : 'MESSAGE';

      let newApiMessage = await PagesService.NewApiMessage.create({
        subject: pageSendDto.subject,
        body: pageSendDto.body,
        priority: type
        //allowFreeResponse: pageSendDto.allowFreeResponse ?
        // pageSendDto.allowFreeResponse : null, possibleAnswers:
        // pageSendDto.possibleAnswers ? pageSendDto.possibleAnswers : null,
        // callbackUrl: pageSendDto.callbackUrl ? pageSendDto.callbackUrl : null
      });
      newApiMessage = await PagesService.NewApiMessage.findOne({
        where: { id: newApiMessage.id }
      }); // we have to
      // reload message
      // from DB as we
      // need
      // get SHA generated by afterCreate Hook
      //const recipients = pageSendDto.recipients;

      return newApiMessage.toJSON();
    } catch (e) {
      this.logger.error(e.message, e.stack);
      throw new Error('Could not persist message request.');
    }
  }

  /**
   * Retrieves the attachments associated with a specific message ID.
   *
   * @param {number} messageId - The ID of the message for which attachments are to be fetched.
   * @return {Promise<Object[]>} A promise that resolves to an array of attachments in JSON format.
   */
  private async getMessageShortAttachments(
    messageId: number
  ): Promise<AttachmentShortDto[]> {
    const NpsAttachment = Entities.sequelize.models.NpsAttachment;
    const attachments = await NpsAttachment.findAll({
      where: {
        npsMessageId: messageId
      },
      attributes: ['fileId', 'fileName', 'fileSize']
    });

    return attachments.map((attachment) => {
      return {
        id: attachment.fileId,
        name: attachment.fileName,
        size: attachment.fileSize
      };
    });
  }

  /**
   * Fetches the list of recipients for a given message by its ID.
   *
   * @param {number} messageId - The unique identifier of the message for which the recipients are to be retrieved.
   * @return {Promise<RecipientDto[]>} A promise that resolves to an array of RecipientDto objects, each containing recipient details.
   */
  private async getMessageRecipientsDto(
    messageId: number
  ): Promise<RecipientDto[]> {
    const recipients: RecipientDto[] = [];
    try {
      const NpsMessageRecipient = Entities.sequelize.models.NpsMessageRecipient;
      const messageRecipients = await NpsMessageRecipient.findAll({
        where: { messageId },
        include: [
          {
            model: Entities.sequelize.models.Account,
            required: true
          }
        ]
      });

      for (const recipient of messageRecipients) {
        const account = recipient.Account;

        recipients.push(
          Object.assign(new RecipientDto(), {
            type: RecipientTypeDto.OPID,
            caption: `${account.firstName} ${account.lastName}`,
            value: account.pagerNumber
          })
        );
      }
    } catch (err) {
      this.logger.error(err.message, err.stack);
    }

    return recipients;
  }

  /**
   * Determines and returns the sender information for a given message.
   *
   * @param {any} message - The message object containing details to identify the sender.
   * @return {Promise<PageFromDto>} A promise that resolves to an instance of PageFromDto, with details such as type, caption, and value of the sender.
   */
  private async getMessageSender(message: any): Promise<PageFromDto> {
    this.logger.debug(`getMessageSender: ${JSON.stringify(message)}`);

    const createPageFromDto = (
      type: PageFromType,
      caption: string,
      value: string | number
    ): PageFromDto =>
      Object.assign(new PageFromDto(), { type, caption, value });

    try {
      if (!message) {
        // Default case for invalid messages
        return createPageFromDto(
          PageFromType.ONPAGE,
          'OnPage Service',
          'OnPage Service'
        );
      }

      // Handle various `creationBy` cases
      switch (message.creationBy) {
        case 4:
          return createPageFromDto(
            PageFromType.EMAIL,
            `Email ${message.emailInfo}`,
            message.emailInfo
          );

        case 3:
          return createPageFromDto(
            PageFromType.PHONE,
            'Phone System',
            'Phone System'
          );

        case 6:
          if (message.Dispatcher) {
            return createPageFromDto(
              PageFromType.DISPATCHER,
              `Dispatcher ${message.Dispatcher?.firstName} ${message.Dispatcher?.lastName}`,
              message.Dispatcher.id
            );
          }
          return createPageFromDto(
            PageFromType.WCTP,
            `WCTP on behalf ${message.Dispatcher?.firstName ?? 'Unknown'} ${message.Dispatcher?.lastName ?? 'Unknown'}`,
            message.Dispatcher?.id ?? 'Unknown'
          );

        case 7:
        case 8:
        case 9:
        case 10:
        case 11: // HUB API creationBy range
          if (message.Dispatcher) {
            return createPageFromDto(
              PageFromType.WCTP,
              `HUB API on behalf ${message.Dispatcher?.firstName} ${message.Dispatcher?.lastName}`,
              message.Dispatcher.id
            );
          }
          return createPageFromDto(PageFromType.WCTP, 'HUB API', 'HUB API');

        case 12:
          if (message.Dispatcher) {
            return createPageFromDto(
              PageFromType.SNPP,
              `SNPP on behalf ${message.Dispatcher.firstName} ${message.Dispatcher.lastName}`,
              message.Dispatcher.id
            );
          }
          return createPageFromDto(PageFromType.WCTP, 'SNPP', 'SNPP');
      }

      // Handle cases for `Account` or `Dispatcher` presence.
      if (message.Account) {
        return createPageFromDto(
          PageFromType.ACCOUNT,
          `${message.Account.firstName} ${message.Account.lastName}`,
          message.Account.id
        );
      }

      if (message.Dispatcher) {
        return createPageFromDto(
          PageFromType.DISPATCHER,
          `${message.Dispatcher.firstName} ${message.Dispatcher.lastName}`,
          message.Dispatcher.id
        );
      }

      // Default case for unhandled scenarios
      return createPageFromDto(
        PageFromType.ONPAGE,
        'OnPage Service',
        'OnPage Service'
      );
    } catch (err) {
      this.logger.error(err.message, err.stack);
      return createPageFromDto(
        PageFromType.ONPAGE,
        'OnPage Service',
        'OnPage Service'
      );
    }
  }
}
